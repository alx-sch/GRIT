generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model User {
  // Primary Key
  id Int @id @default(autoincrement())

  // Core Data
  email             String  @unique
  password          String?
  name              String?
  avatarKey         String?
  confirmationToken String? @unique
  googleId          String?

  // Status Flags
  isConfirmed Boolean @default(false)

  // Relations
  events          Event[]                   @relation("EventAuthor")
  locations       Location[]
  chatMessages    ChatMessage[]
  convMemberships ConversationParticipant[]
  convCreated     Conversation[]
  attending       EventAttendee[]

  // Time Stamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  invitesReceived EventInvite[] @relation("Invitee")
  invitesSent     EventInvite[] @relation("Inviter")
}

model Location {
  // Primary Key
  id Int @id @default(autoincrement())

  // Core data
  name       String
  address    String?
  city       String?
  country    String?
  postalCode String?
  longitude  Float
  latitude   Float

  // Status Flags
  isPublic Boolean @default(false)

  // Foreign Keys
  authorId Int

  // Relations
  author User    @relation(fields: [authorId], references: [id])
  events Event[]

  // Time Stamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Event {
  // Primary key
  id Int @id @default(autoincrement())

  // Core data
  content  String?
  endAt    DateTime
  imageKey String?
  startAt  DateTime
  title    String
  slug     String   @unique

  // Status flags
  isPublished Boolean @default(false)
  isPublic    Boolean @default(true)

  // Foreign keys
  authorId   Int
  locationId Int?

  // Relations
  author       User            @relation("EventAuthor", fields: [authorId], references: [id])
  location     Location?       @relation(fields: [locationId], references: [id])
  conversation Conversation?
  attendees    EventAttendee[]

  // Time Stamps
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  eventInvites EventInvite[]
}

enum ConversationType {
  DIRECT
  EVENT
  GROUP
}

model Conversation {
  // Primary Key
  id String @id @default(uuid())

  // Core Data
  type  ConversationType
  title String?

  // Foregin Keys
  createdBy Int
  eventId   Int? @unique

  // Reations
  creator      User                      @relation(fields: [createdBy], references: [id])
  messages     ChatMessage[]
  event        Event?                    @relation(fields: [eventId], references: [id])
  participants ConversationParticipant[]

  // Time Stamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Explicit join table to track which user is part of which conversation.
model ConversationParticipant {
  conversationId String
  userId         Int

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade) // On delete cascade = Delete join entry when conversation is deleted
  user         User         @relation(fields: [userId], references: [id])

  @@id([conversationId, userId])
  @@index([userId])
}

// Expicit join table to track event attendance
model EventAttendee {
  eventId Int
  userId  Int

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([eventId, userId])
  @@index([userId])
}

model ChatMessage {
  // Primary Key
  id String @id

  // Core Data
  conversationId String
  text           String

  // Foreign Keys
  authorId Int

  // Relations
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  author       User         @relation(fields: [authorId], references: [id])

  // Time Stamps
  createdAt DateTime @default(now())

  @@index([conversationId, createdAt, id])
}

model EventInvite {
  id        Int    @id @default(autoincrement())
  eventId   Int
  inviteeId Int
  inviterId Int
  status    String @default("pending") // "pending", "accepted", "declined"

  event   Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  invitee User  @relation("Invitee", fields: [inviteeId], references: [id], onDelete: Cascade)
  inviter User  @relation("Inviter", fields: [inviterId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([eventId, inviteeId]) // Prevents inviting the same person twice to the same event
}
