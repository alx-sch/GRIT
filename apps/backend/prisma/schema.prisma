generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// User can host events
// User can attend events
// User can add locations
model User {
  id                Int         @id @default(autoincrement())
  createdAt         DateTime    @default(now())
  email             String      @unique
  password          String
  name              String?
  avatarKey         String?

  events            Event[]     @relation("EventAuthor")
  attending         Event[]     @relation("EventAttendees")
  location          Location[]

  isConfirmed       Boolean     @default(false)
  confirmationToken String?     @unique

  chatMessages      ChatMessage[]
  memberships       ConversationParticipant[]
}

// Location has a creator
// Location can have events
model Location {
  id          Int         @id @default(autoincrement())
  author      User        @relation(fields: [authorId], references: [id])
  authorId    Int
  name        String
  city        String?
  country     String?
  postalCode  String?
  longitude   Float
  latitude    Float
  isPublic    Boolean     @default(false)
  address	    String?
  events      Event[]
}

// Event must have a creator
// Event can have attending users
// Event can have a location
model Event {
  id            Int       @id @default(autoincrement())
  createdAt     DateTime  @default(now())
  content       String?
  endAt         DateTime
  isPublic      Boolean   @default(true)
  isPublished   Boolean   @default(false)
  startAt       DateTime
  title         String
  imageKey      String?

  author        User      @relation("EventAuthor", fields: [authorId], references: [id])
  authorId      Int

  attending     User[]    @relation("EventAttendees")

  locationId    Int?
  location      Location? @relation(fields: [locationId], references: [id])

  conversations Conversation[]
}

enum ConversationType {
  EVENT
  GROUP
}

model Conversation {
  id            String              @id @default(uuid())
  type          ConversationType
  eventId       Int?                @unique
  createdAt     DateTime            @default(now())

  participants  ConversationParticipant[]
  messages      ChatMessage[]

  event         Event?              @relation(fields: [eventId], references: [id])
}

// Explicit join table
model ConversationParticipant {
  conversationId String
  userId         Int

  conversation   Conversation   @relation(fields: [conversationId], references: [id], onDelete: Cascade) // On delete cascade = Delete join entry when conversation is deleted
  user           User           @relation(fields: [userId], references: [id])

  @@id([conversationId, userId])
  @@index([userId])
}

model ChatMessage {
  id             String       @id
  conversationId String
  authorId       Int
  text           String
  createdAt      DateTime     @default(now())

  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  author         User         @relation(fields: [authorId], references: [id])

  @@index([conversationId, createdAt, id])
}
